#version 400 core

// kriegt einen 3D-Vektor für die Blickrichtung des Pixels als Input übergeben
// dieses Input wurde aus den Outputs des Vertex-Shaders interpoliert und ist für jeden Pixel verschieden
in vec3 pass_direction;

// gibt die Farbe des Pixels als 4D-RGBA-Vektor aus
out vec4 out_color;

// hier müssen alle selbst geschriebenen Methoden kurz beschrieben werden.
// genauer definiert werden sie dann später im Programm.
vec4 trace(inout vec3 position, vec3 direction);
float distanceEstimation(vec3 p, out vec3 glowColor);
float gridDE(vec3 p);
float snakeDE(vec3 p);
float foodDE(vec3 p);
vec3 colorAt(vec3 p);

// Ortsvektor der Kamera
uniform vec3 cameraPosition;

// Positionen der Schlange
uniform vec3[64] snakePositions;
uniform int snakeLength;
uniform float snakeSphereRadius;

// Positionen der Schlange
uniform vec3[64] secondSnakePositions;
uniform int secondSnakeLength;
uniform float secondSnakeSphereRadius;

// Position des Essens
uniform vec3 foodPosition;
uniform float foodRadius;
uniform mat3 foodRotation;

// Informationen zum Gitter
uniform float gridWidth;

// maximale beim RayMarching genutzte Schrittzahl
#ifndef EFFECT_ACID
	const int maxSteps = 32;
	const vec3 gridColor = vec3(0.25);
#else
	// reduziert, falls der Acid Effect aktiviert ist
	const int maxSteps = 16;
	const vec3 gridColor = vec3(0);
#endif

void main(void){
	
	// setzt die Startposition des Strahls auf die Position der Kameradd
	vec3 position = cameraPosition;
	// normalisiert den vom Vertex-Shader übergebenen Richtungsvektor, d.h. die Länge wird auf 1 gesetzt
	vec3 direction = normalize(pass_direction);
	
	// simuliert einen Lichtstrahl in die Richtung und bestimmt damit die Helligkeit des Pixels
	out_color = trace(position,direction);
	
}

// simuliert einen Lichtstrahl von einen gegebenen Punkt aus in die gegebene Richtung
// gibt Farbe und  Stärke der entsprechenden Schattierung zurück
// setzt den übergeben Vektor auf die Endposition des Strahls
vec4 trace(inout vec3 position, vec3 direction){
	float totalDistance = 0;
	int steps;
	vec3 p;
	float distance;
	float prevDistance;
	vec3 shadeColor = vec3(0);
	vec3 currentGlowColor;
	for (steps=0;steps<maxSteps;steps++){
		// berechnet die derzeitige Position des Lichtstrahls
		p = position+totalDistance*direction;
		// berechnet die Distanz zu den zu rendernden Objekten und errechnet die Farbe des Leuchtens naher Objekte
		prevDistance = distance;
		distance = distanceEstimation(p,currentGlowColor);
		shadeColor += currentGlowColor;
		// bewegt den Strahl um die errechnete Distanz vorwärts
		// dadurch bewegt er sich nach vorne, kann sich aber nicht durch die Objekte durchbewegen
		totalDistance += distance;
		if (distance<0.001){
			// beendet den Loop, wenn der Strahl den Objekten ausreichend nahegekommen ist
			break;
		}
	}
	// ändert die Startposition zur derzeitigen Position
	position += totalDistance*direction;
	//berechnet die Farbe und Stärke der Schattierung
	shadeColor /= steps;
	#ifndef EFFECT_ACID
		float shade;
		if (steps==maxSteps){
			// gibt 0 als Helligkeit zurück, falls der Strahl die Objekte nicht erreicht hat
			shade = 0;
		}else{
			// errechnet die Helligkeit aus der Anzahl der benötigten Schritte bis zum Erreichen des Objekts sowie der letzten Distanz zum Objekt
			shade = 1.0-(float(steps)-(0.001-distance)/(prevDistance-distance))/float(maxSteps);
		}
	#else
		// keine Schatten, falls der Acid Effect aktiviert ist
		float shade = 1;
	#endif
	
	vec3 solidColor = colorAt(position);
	
	return vec4(solidColor*shade+shadeColor*(1-shade),1);
}

// berechnet die Distanz des gegebenen Punktes zu den zu rendernden Objekten, gibt die Farbe des Leuchtens naher Objekte zurück
float distanceEstimation(vec3 p, out vec3 glowColor){
	vec3 distances = vec3(gridDE(p),snakeDE(p),foodDE(p));
	vec3 inverseDistances = 1/distances;
	glowColor = inverseDistances.z/(inverseDistances.x+inverseDistances.y+inverseDistances.z)*vec3(1,0.5,0);
	// prüft, ob der "Cave Effect" eingesetzt werden soll
	#ifdef EFFECT_CAVE
		// witziger Code zur Bildverzerrung
		float d = length(p-cameraPosition);
		return min(distances.x,min(distances.y,distances.z))-0.05*d*d*d*d;
	#else
		// normaler Code
		return min(distances.x,min(distances.y,distances.z));
	#endif
}

// gibt die Farbe des Objektes zurück, das dem Punkt am nächsten ist
vec3 colorAt(vec3 p){
	float d1 = 1/(0.0001+gridDE(p));
	float d2 = 1/(0.0001+snakeDE(p));
	float d3 = 1/(0.0001+foodDE(p));
	float sum = d1+d2+d3;
	vec3 color = d1/sum*gridColor+d2/sum*vec3(0.25,1,0)+d3/sum*vec3(1,0.5,0);
	return sqrt(color);
}

// berechnet die Distanz des gegebenen Punktes zu den Koordinatenachsen
float gridDE(vec3 p){
	// projiziert alle Punkte in den Raum von -0.5 bis +0.5, sodass der sich immer wieder wiederholt
	p = mod(p,1)-vec3(0.5);
	// berechnet die Distanz zu den Koordinatenachsen
	p = max(abs(p)-vec3(gridWidth/2),vec3(0));
	p = vec3(length(p.xy),length(p.yz),length(p.zx));
	return min(p.x,min(p.y,p.z));
}

// berechnet die Distanz des gegebenen Punktes zur Schlange
float snakeDE(vec3 p){
	float d = 100;
	for (int i=0;i<snakeLength;i++){
		d = min(d,length(mod(p-snakePositions[i]+vec3(0.5),1)-vec3(0.5)));
	}
	for (int i=0;i<secondSnakeLength;i++){
		d = min(d,length(mod(p-secondSnakePositions[i]+vec3(0.5),1)-vec3(0.5)));
	}
	return max(d-snakeSphereRadius,2*snakeSphereRadius+0.01-length(p-cameraPosition));
}


// berrechnet die Distanz des gegebenen Punktes zum Futter
float foodDE(vec3 p){
	p = mod(p-foodPosition+vec3(0.5),1)-vec3(0.5);
	p *= foodRotation;
	return length(max(vec3(0),abs(p)-vec3(foodRadius)));
}

